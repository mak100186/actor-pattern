// ===== File: ActorSystem\Program.cs =====
using ActorFramework.AspNetCore.Extensions;
using ActorFramework.Extensions;

using ActorSystem.Actors;
using ActorSystem.Messages;

using Bogus;

using Serilog;

WebApplicationBuilder builder = WebApplication.CreateBuilder(args);

builder.Host.UseSerilog((ctx, lc) => lc
    .ReadFrom.Configuration(ctx.Configuration));

ActorRegistrationBuilder actorRegistrationBuilder = new();
builder.Services.AddActorFramework(builder.Configuration, actorBuilder =>
{
    actorBuilder.AddActor<ContestActor, ContestMessage>();
    actorBuilder.AddActor<PropositionActor, PropositionMessage>();

    actorRegistrationBuilder = actorBuilder;
});

//Add controllers and OpenAPI support
builder.Services
    .AddControllers()
    .AddActorFrameworkJsonPolymorphism(actorRegistrationBuilder);

builder.Services.AddSingleton<Faker<ContestMessage>>(new Faker<ContestMessage>()
        .CustomInstantiator(f => new ContestMessage(
            Key: f.Random.Guid().ToString(),
            FeedProvider: f.Company.CompanyName(),
            Name: f.Commerce.ProductName(),
            Start: f.Date.FutureOffset(),
            End: f.Date.FutureOffset(),
            Delay: f.Random.Int(100, 5000)
        )));

builder.Services.AddSingleton<Faker<PropositionMessage>>(new Faker<PropositionMessage>()
    .CustomInstantiator(f => new PropositionMessage(
        Key: f.Random.Guid().ToString(),
        ContestKey: f.Random.Guid().ToString(),
        Name: f.Commerce.Department(),
        PropositionAvailability: f.PickRandom<PropositionAvailability>(),
        IsOpen: f.Random.Bool(),
        Delay: f.Random.Int(100, 5000)
    )));

builder.Services.AddOpenApi();

WebApplication app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.MapOpenApi();
    app.UseSwaggerUI(options =>
    {
        options.SwaggerEndpoint("/openapi/v1.json", "ActorSystem API v1");
        options.RoutePrefix = "swagger";

        options.DisplayRequestDuration();
        options.EnableTryItOutByDefault();
    });
}

app.UseHttpsRedirection();

app.MapControllers();

await app.RunAsync();

// ===== File: ActorFramework\Abstractions\IActor.cs =====
using ActorFramework.Models;

namespace ActorFramework.Abstractions;

/// <summary>
/// Defines the contract for an actor: how it receives and processes messages.
/// </summary>
public interface IActor
{
    /// <summary>
    /// Handles an incoming message.
    /// </summary>
    /// <param name="message">The message instance to process.</param>
    /// <param name="context">Provides identity and system access for the current actor.</param>
    /// <param name="cancellationToken">The token for the process</param>
    Task OnReceive(IMessage message, ActorContextExternal context, CancellationToken cancellationToken);

    /// <summary>
    /// Handles errors that occur during message processing.
    /// </summary>
    /// <param name="actorId"></param>
    /// <param name="message"></param>
    /// <param name="exception"></param>
    /// <returns></returns>
    Task OnError(string actorId, IMessage message, Exception exception);
}

// ===== File: ActorFramework\Abstractions\IDirector.cs =====
using ActorFramework.Models;

namespace ActorFramework.Abstractions;

public interface IDirector : IDisposable, IAsyncDisposable, IIdentifiable
{
    int TotalQueuedMessageCount { get; }
    DateTimeOffset LastActive { get; }
    void ResumeActors();
    DirectorStateExternal GetState();
    void RegisterActor(string actorId, Func<IActor> actorFactory);
    ValueTask Send(string actorId, IMessage message);
    bool IsBusy();
}


// ===== File: ActorFramework\Abstractions\IEventListener.cs =====
namespace ActorFramework.Abstractions;

public interface IEventListener<in TEvent>
{
    void OnEvent(TEvent evt);
}

// ===== File: ActorFramework\Abstractions\IIdentifiable.cs =====
namespace ActorFramework.Abstractions;

public interface IIdentifiable
{
    string Identifier { get; }
}

// ===== File: ActorFramework\Abstractions\IMailbox.cs =====
using ActorFramework.Models;
using ActorFramework.Runtime.Infrastructure.Internal;

namespace ActorFramework.Abstractions;

/// <summary>
/// A thread-safe, pluggable queue for delivering messages to an actor.
/// </summary>
public interface IMailbox : IDisposable
{
    /// <summary>
    /// Enqueue a message, observing backpressure or overflow policies.
    /// </summary>
    /// <param name="message">The message instance.</param>
    /// <param name="cancellationToken">Cancel waiting if queue is full.</param>
    ValueTask EnqueueAsync(IMessage message, CancellationToken cancellationToken);

    /// <summary>
    /// Returns an async stream of messages for the actor to process. Dequeue the next message, waiting if none are available.
    /// </summary>
    /// <param name="cancellationToken">Cancel waiting on shutdown or timeouts.</param>
    IAsyncEnumerable<MailboxTransaction> DequeueAsync(CancellationToken cancellationToken);

    /// <summary>
    /// Number of messages currently buffered and waiting to be processed.
    /// </summary>
    int Count { get; }

    MailboxStateExternal GetState();
}

// ===== File: ActorFramework\Abstractions\IMessage.cs =====
namespace ActorFramework.Abstractions;

/// <summary>
/// Represents an immutable message that actors exchange.
/// </summary>
public interface IMessage
{
}


// ===== File: ActorFramework\Abstractions\IWorkspace.cs =====
using ActorFramework.Models;

namespace ActorFramework.Abstractions;

public interface IWorkspace
{
    WorkspaceStateExternal GetState();
    IReadOnlyList<IDirector> Directors { get; }
    IDirector? CreateDirector();
    void RemoveDirector(IDirector director);
    void Resume();
}


// ===== File: ActorFramework\Base\IdentifiableBase.cs =====
using ActorFramework.Abstractions;

namespace ActorFramework.Base;

public abstract class IdentifiableBase : IIdentifiable
{
    public string Identifier { get; } = Guid.CreateVersion7().ToString();
}


// ===== File: ActorFramework\Configs\ActorFrameworkOptions.cs =====
using ActorFramework.Constants;

namespace ActorFramework.Configs;

/// <summary>
/// Holds configurable settings for the actor framework.
/// </summary>
public class ActorFrameworkOptions
{
    /// <summary>
    /// The time in seconds after which the idle director would be pruned to conserve resources.
    /// </summary>
    public int DirectorIdleThresholdForPruning { get; set; } = ActorFrameworkConstants.DefaultDirectorIdleThresholdForPruningInSec;

    /// <summary>
    /// Max number of threads or directors inside a workspace.
    /// </summary>
    public int MaxDegreeOfParallelism { get; set; } = ActorFrameworkConstants.DefaultMaxDegreeOfParallelism;

    /// <summary>
    /// Maximum number of messages a mailbox can buffer.
    /// </summary>
    /// <remarks>The default value is defined by <see
    /// cref="ActorFrameworkConstants.DefaultMailboxCapacity"/>.</remarks>
    public int MailboxCapacity { get; set; } = ActorFrameworkConstants.DefaultMailboxCapacity;

    /// <summary>
    /// Gets or sets the policy that determines how the mailbox handles messages when it reaches its capacity. Works if the <see cref="MailboxType"/>  is set to <see cref="MailboxType.Bounded"/>.
    /// </summary>
    /// <remarks>The default value is defined by <see
    /// cref="ActorFrameworkConstants.DefaultOverflowPolicy"/>.</remarks>
    public OverflowPolicy MailboxOverflowPolicy { get; set; } = ActorFrameworkConstants.DefaultOverflowPolicy;

    /// <summary>
    /// The type of mailbox to use for actors.
    /// </summary>
    /// <remarks>The default value is defined by <see
    /// cref="ActorFrameworkConstants.DefaultMailboxType"/>.</remarks>
    public MailboxType MailboxType { get; set; } = ActorFrameworkConstants.DefaultMailboxType;

    /// <summary>
    /// The number of times to retry processing a message if an exception occurs.
    /// </summary>
    public int RetryCountIfExceptionOccurs { get; set; } = ActorFrameworkConstants.DefaultRetryCountIfExceptionOccurs;

    /// <summary>
    /// Gets or sets a value indicating whether the execution should stop when an unhandled exception occurs.
    /// </summary>
    public bool ShouldStopOnUnhandledException { get; set; } = ActorFrameworkConstants.DefaultExecutionBehaviorOnExceedingConfiguredAmountOfExceptionCount;
}

// ===== File: ActorFramework\Configs\MailboxType.cs =====
namespace ActorFramework.Configs;

public enum MailboxType
{
    ConcurrentQueue
}

// ===== File: ActorFramework\Configs\OverflowPolicy.cs =====
namespace ActorFramework.Configs;

public enum OverflowPolicy
{
    BlockProducer,   // Wait until space frees
    DropOldest,      // Evict oldest in queue
    DropNewest,      // Reject the incoming message
    FailFast         // Throw on overflow
}

// ===== File: ActorFramework\Constants\ActorFrameworkConstants.cs =====
using ActorFramework.Configs;

namespace ActorFramework.Constants;

/// <summary>
/// Framework-wide constants.
/// </summary>
public static class ActorFrameworkConstants
{
    /// <summary>
    /// The time in seconds after which the idle director would be pruned to conserve resources.
    /// </summary>
    public const int DefaultDirectorIdleThresholdForPruningInSec = 30;

    /// <summary>
    /// The max number of directors inside a workspace. Each director is a thread that schedules actors on it.
    /// </summary>
    public const int DefaultMaxDegreeOfParallelism = 10;

    /// <summary>
    /// Fallback mailbox capacity if no configuration is provided.
    /// </summary>
    public const int DefaultMailboxCapacity = 1000;

    /// <summary>
    /// By default, how to handle message overflow in the mailbox.
    /// </summary>
    public const OverflowPolicy DefaultOverflowPolicy = OverflowPolicy.BlockProducer;

    /// <summary>
    /// By default, the type of mailbox used for actors.
    /// </summary>
    public const MailboxType DefaultMailboxType = MailboxType.ConcurrentQueue;

    /// <summary>
    /// The default number of retries if an exception occurs while processing a message.
    /// </summary>
    public const int DefaultRetryCountIfExceptionOccurs = 3;

    /// <summary>
    /// Default execution behavior when the configured amount of exception count is exceeded.
    /// </summary>
    public const bool DefaultExecutionBehaviorOnExceedingConfiguredAmountOfExceptionCount = true;

    // Logging templates used across the Actor Framework
    public const string ActorRetryingOnMessage = "Actor '{ActorId}' retry {Attempt}/{RetryCount} on message";
    public const string CommitFailedAsMessageWasNotAtHeadOfQueue = "Commit failed: message was not at head of queue.";
    public const string ActorFaultedAfterMaxRetriesPausing = "Actor '{ActorId}' faulted on message after max retries; pausing";
    public const string ActorSkippingFailedMessage = "Actor '{ActorId}' skipping failed message and continuing";
    public const string ActorRollbackFailedMessage = "Rolling back transaction for actor {ActorId} due to unhandled exception.";
    public const string ThreadRunningDirector = "Thread [{ThreadId}] - Director[{Identifier}] - Actor[{Identifier}]";
    public const string ResumingActor = "Resuming actor '{ActorId}'";
    public const string RemovingDirector = "Removing director '{DirectorId}'";
    public const string ShuttingDownDirectorCancellingActors = "Shutting down Director, cancelling actors...";
    public const string ShuttingDownWorkspaceDisposingDirectors = "Shutting down workspace, disposing directors...";
    public const string DispatchLoopsCompletedDisposingMailboxes = "Dispatch loops completed, disposing mailboxes...";
    public const string EnqueueOpBlockedAsMailboxAtCapacity = "Producer blocked as Mailbox is at capacity.";
    public const string EnqueueOpDropNewest = "Dropping incoming message due to overflow policy: {@Message}";
    public const string EnqueueOpDropOldest = "Dropping oldest message due to overflow policy: {@Message}";
    public const string EnqueueOpMailboxFull = "Message not added as mailbox is full: {@Message}";

    // User-facing messages and formats
    public const string ActorNotFoundFormat = "Actor '{0}' not found.";
    public const string ActorAlreadyProcessing = "Actor already processing.";
    public const string ActorResumed = "Actor resumed.";
}

// ===== File: ActorFramework\Events\InMemoryEventBus.cs =====
using ActorFramework.Abstractions;

namespace ActorFramework.Events;

public interface IEventBus
{
    void Publish<TEvent>(TEvent evt);
    void Register<TEvent>(IEventListener<TEvent> listener);
    void Unregister<TEvent>(IEventListener<TEvent> listener);
}

public class InMemoryEventBus : IEventBus
{
    private readonly List<object> _listeners = new();

    public void Register<TEvent>(IEventListener<TEvent> listener)
    {
        _listeners.Add(listener);
    }

    public void Unregister<TEvent>(IEventListener<TEvent> listener)
    {
        _listeners.Remove(listener);
    }

    public void Publish<TEvent>(TEvent evt)
    {
        foreach (IEventListener<TEvent> listener in _listeners.OfType<IEventListener<TEvent>>())
        {
            listener.OnEvent(evt);
        }
    }
}

// ===== File: ActorFramework\Exceptions\ActorFrameworkExceptions.cs =====
using ActorFramework.Configs;

namespace ActorFramework.Exceptions;

public class MailboxFullException() : Exception("Mailbox is full");

public class OverflowPolicyNotHandledException(OverflowPolicy policy, string source) : Exception($"The OverflowPolicy[{policy}] is not handled in [{source}]");

public class MailboxTypeNotHandledException(MailboxType type, string source) : Exception($"The MailboxType[{type}] is not handled in [{source}].");

public class ActorIdAlreadyRegisteredException(string actorId) : Exception($"Actor '{actorId}' is already registered.");

public class ActorIdNotFoundException(string actorId) : Exception($"Actor '{actorId}' not found.");

public class ActorPausedException(string actorId) : Exception($"Actor '{actorId}' is in a paused state and cannot accept new messages.");

// ===== File: ActorFramework\Extensions\DateTimeOffsetExtensions.cs =====
namespace ActorFramework.Extensions;

public static class DateTimeOffsetExtensions
{
    /// <summary>
    /// Returns a string like "5 minutes ago at 3:15 PM" (using the caller's local time).
    /// </summary>
    public static string ToRelativeTimeWithLocal(this DateTimeOffset past, DateTimeOffset? relativeTo = null)
    {
        if (past == DateTimeOffset.MinValue)
        {
            return "Never";
        }

        // Compute span from now (in UTC) to the past timestamp
        DateTimeOffset nowUtc = (relativeTo ?? DateTimeOffset.UtcNow).ToUniversalTime();
        TimeSpan span = nowUtc - past.ToUniversalTime();

        // Determine the relative-time part
        string relative;
        if (span.TotalSeconds < 0)
        {
            relative = "just now";
        }
        else if (span.TotalSeconds < 60)
        {
            int sec = (int)span.TotalSeconds;
            relative = $"{sec} second{Plural(sec)} ago";
        }
        else if (span.TotalMinutes < 60)
        {
            int min = (int)span.TotalMinutes;
            relative = $"{min} minute{Plural(min)} ago";
        }
        else if (span.TotalHours < 24)
        {
            int hr = (int)span.TotalHours;
            relative = $"{hr} hour{Plural(hr)} ago";
        }
        else
        {
            int days = (int)span.TotalDays;
            relative = $"{days} day{Plural(days)} ago";
        }

        // Convert the original timestamp to local time for display
        DateTimeOffset localTime = past.ToLocalTime();
        // Format e.g. "3:15 PM" – adjust format string to taste
        string localString = localTime.ToString("h:mm tt");

        return $"{relative} at {localString}";
    }

    private static string Plural(double value) => value >= 2 ? "s" : string.Empty;
}

// ===== File: ActorFramework\Extensions\DependencyExtensions.cs =====
using ActorFramework.Abstractions;
using ActorFramework.Configs;
using ActorFramework.Events;
using ActorFramework.Runtime.Orchestration;

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace ActorFramework.Extensions;

public static class DependencyExtensions
{
    private const string ActorFrameworkSectionName = "ActorFrameworkOptions";

    public static IServiceCollection AddActorFramework(this IServiceCollection services, IConfiguration configuration, Action<ActorRegistrationBuilder> configure)
    {
        services.AddSingleton<IEventBus, InMemoryEventBus>();
        services.AddSingleton<IWorkspace, Workspace>();
        services.AddSingleton<WorkspaceLoadBalancer>();

        ActorRegistrationBuilder builder = new();
        configure(builder);

        services.AddSingleton(builder);

        services
            .AddOptions<ActorFrameworkOptions>()
            .Bind(configuration.GetSection(ActorFrameworkSectionName));

        return services;
    }
}

public class ActorRegistrationBuilder
{
    private List<Type> _actorTypes = [];
    private Dictionary<Type, Type> _messageToActorMap = [];

    public IReadOnlyDictionary<Type, Type> MessageToActorMap => _messageToActorMap;

    public IReadOnlyList<Type> ActorTypes => _actorTypes;

    public ActorRegistrationBuilder AddActor<TActor, TMessage>()
        where TActor : class, IActor
        where TMessage : class, IMessage
    {
        _actorTypes.Add(typeof(TActor));
        _messageToActorMap[typeof(TMessage)] = typeof(TActor);

        return this;
    }
}

// ===== File: ActorFramework\Extensions\ExceptionExtensions.cs =====
using System.Globalization;

namespace ActorFramework.Extensions;

public static class ExceptionExtensions
{
    /// <summary>
    /// Returns a human‐readable exception description, or null if no exception.
    /// </summary>
    /// <param name="exception">The exception to describe.</param>
    /// <param name="pausedAtUtc">
    /// The UTC timestamp when the exception was observed; 
    /// will be converted to local time in the output.
    /// </param>
    /// <returns>
    /// Null if <paramref name="exception"/> is null; otherwise
    /// "{ExceptionType} occurred at {LocalTime}: {Exception.Message}".
    /// </returns>
    public static string GetExceptionText(this Exception? exception, DateTimeOffset? pausedAtUtc)
    {
        if (exception is null || pausedAtUtc is null)
        {
            return "No exceptions recorded";
        }

        // Convert the paused‐at UTC timestamp to local time and format
        var localTime = pausedAtUtc.Value
            .ToLocalTime()
            .ToString("h:mm tt", CultureInfo.CurrentCulture);

        // Use the exception's runtime type name
        var typeName = exception.GetType().Name;
        var message = exception.Message;

        return $"{typeName} occurred at {localTime}: {message}";
    }
}

// ===== File: ActorFramework\Models\ActorContext.cs =====
using ActorFramework.Abstractions;

namespace ActorFramework.Models;

/// <summary>
/// Provides contextual information and capabilities to an actor instance.
/// </summary>
public sealed class ActorContext
{
    /// <summary>
    /// The unique identifier of the actor.
    /// </summary>
    public string ActorId { get; }

    /// <summary>
    /// The central orchestrator managing this actor.
    /// </summary>
    public IDirector Director { get; }

    internal ActorContext(string actorId, IDirector director)
    {
        ActorId = actorId;
        Director = director;
    }

    public ActorContextExternal ToExternal(int pendingMessageCount, DateTimeOffset lastReceivedMessageTimestamp)
    {
        return new ActorContextExternal(Director.Identifier, ActorId, pendingMessageCount, lastReceivedMessageTimestamp);
    }
}


// ===== File: ActorFramework\Models\ActorContextExternal.cs =====
namespace ActorFramework.Models;

public record ActorContextExternal(string DirectorId, string ActorId, int PendingMessagesCount, DateTimeOffset LastMessageReceivedTimestamp);


// ===== File: ActorFramework\Models\ActorStateExternal.cs =====
namespace ActorFramework.Models;

/// <summary>
/// The state of the registry for actors. This is an external representation of the actor registry state.
/// </summary>
/// <param name="IsPaused">Whether the actor is in a paused state due to an error/exception.</param>
/// <param name="MailboxState">The count of messages still pending in the mailbox for this actor</param>
/// <param name="TimestampText">The timestamp of the last message processed by this actor</param>
/// <param name="ExceptionText">The exception details of the last exception received by this actor. This gets overriden if the last message was processed successfully</param>
public record ActorStateExternal(string Identifier, string ActorId, MailboxStateExternal MailboxState, bool IsPaused, string TimestampText, string ExceptionText);


// ===== File: ActorFramework\Models\DirectorStateExternal.cs =====
namespace ActorFramework.Models;

/// <summary>
/// The state of the director. This is an external representation for director state.
/// </summary>
/// <typeparam name="TMessage"></typeparam>
/// <param name="ActorCount"></param>
/// <param name="ActorStates"></param>
/// <param name="IsBusy"></param>
/// <param name="TimestampText"></param>
public record DirectorStateExternal(string Identifier, int ActorCount, int TotalMessages, ActorStateExternal[] ActorStates, bool IsBusy, string TimestampText);


// ===== File: ActorFramework\Models\MailboxStateExternal.cs =====
using ActorFramework.Abstractions;

namespace ActorFramework.Models;

/// <summary>
/// The state of the mailbox for the actor. This is an external representation of the state.
/// </summary>
/// <param name="PendingMessageCount">The count of messages still pending in the mailbox for this actor</param>
/// <param name="Messages">Serialized messages in the mailbox</param>
public record MailboxStateExternal(int PendingMessageCount, IMessage[] Messages);

// ===== File: ActorFramework\Models\WorkspaceStateExternal.cs =====
namespace ActorFramework.Models;


/// <summary>
/// Represents the state of the workspace. This is for external representation only.
/// </summary>
/// <param name="DirectorCount"></param>
/// <param name="DirectorStates"></param>
public record WorkspaceStateExternal(string Identifier, int DirectorCount, DirectorStateExternal[] DirectorStates);


// ===== File: ActorFramework.AspNetCore\Extensions\ActorFrameworkAspNetCoreExtensions.cs =====
using System.Text.Json.Serialization.Metadata;

using ActorFramework.Abstractions;
using ActorFramework.Extensions;

using Microsoft.Extensions.DependencyInjection;

namespace ActorFramework.AspNetCore.Extensions;

public static class ActorFrameworkAspNetCoreExtensions
{
    public static IMvcBuilder AddActorFrameworkJsonPolymorphism(
        this IMvcBuilder mvcBuilder,
        ActorRegistrationBuilder builder)
    {
        return mvcBuilder.AddJsonOptions(options =>
        {
            options.JsonSerializerOptions.WriteIndented = true;

            options.JsonSerializerOptions.TypeInfoResolverChain.Insert(
                0,
                new DefaultJsonTypeInfoResolver
                {
                    Modifiers =
                    {
                        typeInfo =>
                        {
                            if (typeInfo.Type == typeof(IMessage))
                            {
                                JsonPolymorphismOptions polyOptions = new() {
                                    TypeDiscriminatorPropertyName = "$type",
                                    IgnoreUnrecognizedTypeDiscriminators = true
                                };

                                foreach (KeyValuePair<Type, Type> kvp in builder.MessageToActorMap)
                                {
                                    Type messageType = kvp.Key;
                                    string discriminator = char.ToLowerInvariant(messageType.Name[0]) + messageType.Name[1..];
                                    polyOptions.DerivedTypes.Add(new JsonDerivedType(messageType, discriminator));
                                }

                                typeInfo.PolymorphismOptions = polyOptions;
                            }
                        }
                    }
                }
            );
        });
    }
}

// ===== File: ActorSystem\Actors\ContestActor.cs =====
using ActorFramework.Abstractions;
using ActorFramework.Models;

using ActorSystem.Messages;

namespace ActorSystem.Actors;

public class ContestActor(ILogger<ContestActor> logger) : IActor
{
    public Task OnError(string actorId, IMessage message, Exception exception)
    {
        //actor id can be used to resume if needed
        logger.LogError(exception, "Error processing message {@Message} on actor [{ActorId}]", message, actorId);
        return Task.CompletedTask;
    }

    public async Task OnReceive(IMessage message, ActorContextExternal context, CancellationToken cancellationToken)
    {
        if (message is ContestMessage contestMessage)
        {
            int delayMs = contestMessage.Delay;

            logger.LogInformation("Received ContestMessage: {Key} {FeedProvider} {Name} {Start} {End} {Delay} ms",
                contestMessage.Key,
                contestMessage.FeedProvider,
                contestMessage.Name,
                contestMessage.Start,
                contestMessage.End,
                delayMs);

            while (delayMs > 0 && !cancellationToken.IsCancellationRequested)
            {
                logger.LogInformation("DirectorId: {DirectorId} - ActorId: {ActorId} - Processing ContestMessage {MessageKey} running on Thread {ThreadId}", context.DirectorId, context.ActorId, contestMessage.Key, Environment.CurrentManagedThreadId);

                await Task.Delay(100, cancellationToken);
                delayMs -= 100;
            }

            logger.LogInformation("Processed: {ActorId} {Delay} ms", context.ActorId, contestMessage.Delay);
        }
    }
}


// ===== File: ActorSystem\Actors\PropositionActor.cs =====
using ActorFramework.Abstractions;
using ActorFramework.Models;

using ActorSystem.Messages;

namespace ActorSystem.Actors;

public class PropositionActor(ILogger<PropositionActor> logger) : IActor
{
    public Task OnError(string actorId, IMessage message, Exception exception)
    {
        //actor id can be used to resume if needed
        logger.LogError(exception, "Error processing message {@Message} on actor [{ActorId}]", message, actorId);
        return Task.CompletedTask;
    }

    public async Task OnReceive(IMessage message, ActorContextExternal context, CancellationToken cancellationToken)
    {
        if (message is PropositionMessage propositionMessage)
        {
            int delayMs = propositionMessage.Delay;

            logger.LogInformation("Received PropositionMessage: {Key} {ContestKey} {Name} {Availability} {IsOpen} {Delay} ms",
                propositionMessage.Key,
                propositionMessage.ContestKey,
                propositionMessage.Name,
                propositionMessage.PropositionAvailability,
                propositionMessage.IsOpen,
                delayMs);

            while (delayMs > 0 && !cancellationToken.IsCancellationRequested)
            {
                logger.LogInformation("DirectorId: {DirectorId} - ActorId: {ActorId} - Processing PropositionMessage {MessageKey} running on Thread {ThreadId}", context.DirectorId, context.ActorId, propositionMessage.Key, Environment.CurrentManagedThreadId);

                await Task.Delay(100, cancellationToken);
                delayMs -= 100;
            }

            logger.LogInformation("Processed: {ActorId} {Delay} ms", context.ActorId, propositionMessage.Delay);
        }
    }
}

// ===== File: ActorSystem\Controllers\WorkspaceController.cs =====
using System.Net;

using ActorFramework.Abstractions;
using ActorFramework.Models;
using ActorFramework.Runtime.Orchestration;

using ActorSystem.Messages;

using Bogus;

using Microsoft.AspNetCore.Mvc;

namespace ActorSystem.Controllers;

[ApiController]
[Route("[controller]")]
public class WorkspaceController(
    IWorkspace workspace,
    Faker<ContestMessage> contestFaker,
    Faker<PropositionMessage> propositionFaker,
    WorkspaceLoadBalancer workspaceLoadBalancer) : ControllerBase
{

    [HttpGet("SendMessages")]
    [ProducesResponseType(typeof(string), (int)HttpStatusCode.OK)]
    public async Task<IActionResult> SendMessages(int countOfMessagesToGenerate)
    {
        IMessage message;

        for (int i = 0; i < countOfMessagesToGenerate; i++)
        {
            if (i % 2 == 0)
                message = contestFaker.Generate();
            else
                message = propositionFaker.Generate();

            await workspaceLoadBalancer.RouteAsync(message);
        }

        return Ok("Messages sent.");
    }

    [HttpGet("PruneWorkspace")]
    public IActionResult PruneWorkspace()
    {
        workspaceLoadBalancer.PruneIdleDirectors();
        return Ok();
    }

    [HttpGet("WorkspaceState")]
    [ProducesResponseType(typeof(IReadOnlyList<IReadOnlyDictionary<string, ActorStateExternal>>), (int)HttpStatusCode.OK)]
    public IActionResult WorkspaceState()
    {
        WorkspaceStateExternal statuses = workspace.GetState();
        return Ok(statuses);
    }
}


// ===== File: ActorSystem\Messages\ContestMessage.cs =====
using ActorFramework.Abstractions;

namespace ActorSystem.Messages;

public record ContestMessage(string Key, string FeedProvider, string Name, DateTimeOffset Start, DateTimeOffset End, int Delay) : IMessage;


// ===== File: ActorSystem\Messages\PropositionMessage.cs =====
using ActorFramework.Abstractions;

namespace ActorSystem.Messages;


public enum PropositionAvailability
{
    PreGame,
    InPlay
}

public record PropositionMessage(string Key, string ContestKey, string Name, PropositionAvailability PropositionAvailability, bool IsOpen, int Delay) : IMessage;


// ===== File: ActorWorkspace\Abstractions\IWorkspace.cs =====
using ActorFramework.Abstractions;

using ActorWorkspace.Models;

namespace ActorWorkspace.Abstractions;

public interface IWorkspace
{
    WorkspaceStateExternal<IMessage> GetState();
    IReadOnlyList<IDirector<IMessage>> Directors { get; }
    IDirector<IMessage> CreateDirector();
    void RemoveDirector(IDirector<IMessage> director);
    void Resume();
}


// ===== File: ActorWorkspace\Extensions\DependencyExtensions.cs =====
using ActorFramework.Abstractions;
using ActorFramework.Configs;

using ActorWorkspace.Abstractions;
using ActorWorkspace.Runtime.Infrastructure;
using ActorWorkspace.Runtime.Orchestration;

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace ActorWorkspace.Extensions;

public static class DependencyExtensions
{
    private const string ActorFrameworkSectionName = "ActorFrameworkOptions";

    public static IServiceCollection AddActorWorkspace(this IServiceCollection services, IConfiguration configuration, Action<ActorRegistrationBuilder> configure)
    {
        services.AddSingleton<IWorkspace, Workspace>();
        services.AddSingleton<WorkspaceLoadBalancer>();

        ActorRegistrationBuilder builder = new();
        configure(builder);

        services.AddSingleton(builder);

        services
            .AddOptions<ActorFrameworkOptions>()
            .Bind(configuration.GetSection(ActorFrameworkSectionName));

        return services;
    }
}

public class ActorRegistrationBuilder
{
    private List<Type> _actorTypes = [];
    private Dictionary<Type, Type> _messageToActorMap = [];

    public IReadOnlyDictionary<Type, Type> MessageToActorMap => _messageToActorMap;

    public IReadOnlyList<Type> ActorTypes => _actorTypes;

    public ActorRegistrationBuilder AddActor<TActor, TMessage>()
        where TActor : class, IActor<TMessage>
        where TMessage : class, IMessage
    {
        _actorTypes.Add(typeof(TActor));
        _messageToActorMap[typeof(TMessage)] = typeof(TActor);

        return this;
    }
}

// ===== File: ActorWorkspace\Models\WorkspaceStateExternal.cs =====
using ActorFramework.Abstractions;
using ActorFramework.Models;

namespace ActorWorkspace.Models;

public record WorkspaceStateExternal<TMessage>(int DirectorCount, DirectorStateExternal<TMessage>[] DirectorStates)
    where TMessage : class, IMessage;


// ===== File: ActorFramework\Events\Poco\ActorDisposedEvent.cs =====
namespace ActorFramework.Events.Poco;

public sealed class ActorDisposedEvent
{
    public string ActorId { get; }
    public DateTimeOffset Timestamp { get; }

    public ActorDisposedEvent(string actorId)
    {
        ActorId = actorId;
        Timestamp = DateTimeOffset.UtcNow;
    }
}

// ===== File: ActorFramework\Events\Poco\ActorIdleEvent.cs =====
namespace ActorFramework.Events.Poco;

public sealed class ActorIdleEvent
{
    public string ActorId { get; }
    public DateTimeOffset Timestamp { get; }

    public ActorIdleEvent(string actorId)
    {
        ActorId = actorId;
        Timestamp = DateTimeOffset.UtcNow;
    }
}


// ===== File: ActorFramework\Events\Poco\ActorPausedEvent.cs =====
namespace ActorFramework.Events.Poco;

public sealed class ActorPausedEvent
{
    public string ActorId { get; }
    public Exception? Exception { get; }
    public DateTimeOffset Timestamp { get; }

    public ActorPausedEvent(string actorId, Exception? exception)
    {
        ActorId = actorId;
        Exception = exception;
        Timestamp = DateTimeOffset.UtcNow;
    }
}


// ===== File: ActorFramework\Events\Poco\ActorReceivedMessageEvent.cs =====
namespace ActorFramework.Events.Poco;

public sealed class ActorReceivedMessageEvent
{
    public string ActorId { get; }
    public DateTimeOffset Timestamp { get; }

    public ActorReceivedMessageEvent(string actorId)
    {
        ActorId = actorId;
        Timestamp = DateTimeOffset.UtcNow;
    }
}


// ===== File: ActorFramework\Events\Poco\ActorRegisteredEvent.cs =====
namespace ActorFramework.Events.Poco;

public sealed class ActorRegisteredEvent
{
    public string ActorId { get; }
    public string DirectorId { get; }
    public DateTimeOffset Timestamp { get; }

    public ActorRegisteredEvent(string actorId, string directorId)
    {
        ActorId = actorId;
        DirectorId = directorId;
        Timestamp = DateTimeOffset.UtcNow;
    }
}


// ===== File: ActorFramework\Events\Poco\ActorResumedEvent.cs =====
namespace ActorFramework.Events.Poco;

public sealed class ActorResumedEvent
{
    public string ActorId { get; }
    public DateTimeOffset Timestamp { get; }

    public ActorResumedEvent(string actorId)
    {
        ActorId = actorId;
        Timestamp = DateTimeOffset.UtcNow;
    }
}


// ===== File: ActorFramework\Events\Poco\DirectorDisposedEvent.cs =====
namespace ActorFramework.Events.Poco;

public sealed class DirectorDisposedEvent
{
    public string WorkspaceId { get; }
    public string DirectorId { get; }
    public DateTimeOffset Timestamp { get; }

    public DirectorDisposedEvent(string directorId, string workspaceId)
    {
        WorkspaceId = workspaceId;
        DirectorId = directorId;
        Timestamp = DateTimeOffset.UtcNow;
    }
}


// ===== File: ActorFramework\Events\Poco\DirectorReceivedMessageEvent.cs =====
namespace ActorFramework.Events.Poco;

public sealed class DirectorReceivedMessageEvent
{
    public string DirectorId { get; }
    public DateTimeOffset Timestamp { get; }

    public DirectorReceivedMessageEvent(string directorId)
    {
        DirectorId = directorId;
        Timestamp = DateTimeOffset.UtcNow;
    }
}


// ===== File: ActorFramework\Events\Poco\DirectorRegisteredEvent.cs =====
namespace ActorFramework.Events.Poco;

public sealed class DirectorRegisteredEvent
{
    public string WorkspaceId { get; }
    public string DirectorId { get; }
    public DateTimeOffset Timestamp { get; }

    public DirectorRegisteredEvent(string directorId, string workspaceId)
    {
        WorkspaceId = workspaceId;
        DirectorId = directorId;
        Timestamp = DateTimeOffset.UtcNow;
    }
}


// ===== File: ActorFramework\Events\Poco\ThreadInformationEvent.cs =====
namespace ActorFramework.Events.Poco;

public sealed class ThreadInformationEvent
{
    public string ActorId { get; }
    public string ThreadId { get; }
    public string DirectorId { get; }
    public DateTimeOffset Timestamp { get; }

    public ThreadInformationEvent(string directorId, string actorId, string threadId)
    {
        ActorId = actorId;
        ThreadId = threadId;
        DirectorId = directorId;
        Timestamp = DateTimeOffset.UtcNow;
    }
}

// ===== File: ActorFramework\Events\Poco\WorkspaceCapacityReachedEvent.cs =====
namespace ActorFramework.Events.Poco;

public sealed class WorkspaceCapacityReachedEvent
{
    public string WorkspaceId { get; }
    public DateTimeOffset Timestamp { get; }

    public WorkspaceCapacityReachedEvent(string workspaceId)
    {
        WorkspaceId = workspaceId;
        Timestamp = DateTimeOffset.UtcNow;
    }
}


// ===== File: ActorFramework\Runtime\Infrastructure\ConcurrentQueueMailbox.cs =====
using System.Collections.Concurrent;
using System.Runtime.CompilerServices;

using ActorFramework.Abstractions;
using ActorFramework.Configs;
using ActorFramework.Constants;
using ActorFramework.Exceptions;
using ActorFramework.Models;
using ActorFramework.Runtime.Infrastructure.Internal;

using Microsoft.Extensions.Logging;

namespace ActorFramework.Runtime.Infrastructure;

public sealed partial class ConcurrentQueueMailbox(ActorFrameworkOptions actorFrameworkOptions, ILogger logger)
{
    private readonly ConcurrentQueue<IMessage> _queue = new();

    private const int SpinWaitOnBlockedProducerDelayMs = 10;

    /// Maximum number of messages the mailbox can hold.
    private int Capacity { get; } = actorFrameworkOptions?.MailboxCapacity
                                    ?? ActorFrameworkConstants.DefaultMailboxCapacity;

    /// Defines how the mailbox handles overflow when full.
    private OverflowPolicy OverflowPolicy { get; } = actorFrameworkOptions?.MailboxOverflowPolicy
                                                     ?? ActorFrameworkConstants.DefaultOverflowPolicy;

    private readonly ILogger Logger = logger;

    private long Pending;

    private readonly SemaphoreSlim _signal = new(0);

    // Commit the transaction by removing the message from the queue
    private void OnCommitInternal(IMessage message) =>
        Interlocked.Decrement(ref Pending);

    // Release the signal to unblock any waiting Dequeue calls
    private void OnRollbackInternal(IMessage message) =>
        _signal.Release();

    // unblock any waiting Dequeue calls
    private void Stop() => _signal.Release(int.MaxValue);

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    private void Dispose(bool disposing)
    {
        if (disposing)
        {
            Stop();
            _signal.Dispose();
        }
    }

}
public sealed partial class ConcurrentQueueMailbox
    : IMailbox
{
    public int Count => (int)Interlocked.Read(ref Pending);
    /// <inheritdoc />
    public MailboxStateExternal GetState()
    {
        IMessage[] mailboxItems = [.. _queue];
        return new(mailboxItems.Length, mailboxItems);
    }

    public async ValueTask EnqueueAsync(IMessage message, CancellationToken cancellationToken)
    {
        // Backpressure / overflow logic
        if (Capacity > 0 && Interlocked.Read(ref Pending) >= Capacity)
        {
            switch (OverflowPolicy)
            {
                case OverflowPolicy.BlockProducer:
                    Logger.LogInformation(ActorFrameworkConstants.EnqueueOpBlockedAsMailboxAtCapacity);

                    // spin-wait until there's room
                    while (Interlocked.Read(ref Pending) >= Capacity)
                    {
                        await Task.Delay(SpinWaitOnBlockedProducerDelayMs, cancellationToken).ConfigureAwait(false);
                    }
                    break;

                case OverflowPolicy.DropNewest:
                    Logger.LogInformation(ActorFrameworkConstants.EnqueueOpDropNewest, message);
                    return;

                case OverflowPolicy.DropOldest:
                    if (_queue.TryDequeue(out IMessage? dequeuedMessage))
                    {
                        Logger.LogInformation(ActorFrameworkConstants.EnqueueOpDropOldest, dequeuedMessage);
                        Interlocked.Decrement(ref Pending);
                    }
                    break;

                case OverflowPolicy.FailFast:
                    Logger.LogInformation(ActorFrameworkConstants.EnqueueOpMailboxFull, message);
                    throw new MailboxFullException();

                default:
                    throw new OverflowPolicyNotHandledException(OverflowPolicy, nameof(ConcurrentQueueMailbox));
            }
        }

        // Enqueue and signal the dispatcher
        _queue.Enqueue(message);
        Interlocked.Increment(ref Pending);
        _signal.Release();
    }

    public async IAsyncEnumerable<MailboxTransaction> DequeueAsync([EnumeratorCancellation] CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            await _signal.WaitAsync(cancellationToken).ConfigureAwait(false);

            if (_queue.TryPeek(out IMessage? message))
            {
                yield return new(_queue, message, OnCommitInternal, OnRollbackInternal);
            }
        }
    }
}

// ===== File: ActorFramework\Runtime\Orchestration\Director.cs =====
using ActorFramework.Abstractions;
using ActorFramework.Configs;
using ActorFramework.Events;
using ActorFramework.Events.Poco;
using ActorFramework.Exceptions;
using ActorFramework.Extensions;
using ActorFramework.Models;
using ActorFramework.Runtime.Infrastructure;
using ActorFramework.Runtime.Orchestration.Internal;

using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

using static ActorFramework.Constants.ActorFrameworkConstants;

namespace ActorFramework.Runtime.Orchestration;

/// <summary>
/// Central orchestrator that registers actors, routes messages, and manages lifecycles.
/// </summary>
public sealed class Director : BaseDirector,
    IDirector,
    IEventListener<ActorReceivedMessageEvent>
{
    public DateTimeOffset LastActive { get; private set; } = DateTimeOffset.MinValue;

    public int TotalQueuedMessageCount => Registry.Sum(kvp => kvp.Value.Mailbox.Count);

    public Director(IOptions<ActorFrameworkOptions> options, ILogger<Director> logger, IEventBus eventBus) : base(options, logger, eventBus)
    {
        eventBus.Register<ActorReceivedMessageEvent>(this);
    }

    public void OnEvent(ActorReceivedMessageEvent evt)
    {
        LastActive = DateTimeOffset.UtcNow;
    }

    protected override void Cleanup()
    {
        base.Cleanup();

        EventBus.Unregister<ActorReceivedMessageEvent>(this);
    }

    public bool IsBusy()
    {
        if (Registry.Values.Any(x => x.IsPaused))
            return true;

        if (Registry.Values.Any(x => x.Mailbox.Count > 0))
            return true;

        return false;
    }

    /// <summary>
    /// Returns the number of pending messages in each actor’s mailbox.
    /// </summary>
    public DirectorStateExternal GetState()
    {
        ActorStateExternal[] actorStates = [.. Registry.Select(kvp =>
                new ActorStateExternal(
                    kvp.Value.Identifier,
                    kvp.Key,
                    kvp.Value.Mailbox.GetState(),
                    kvp.Value.IsPaused,
                    kvp.Value.LastMessageReceivedTimestamp.ToRelativeTimeWithLocal(),
                    kvp.Value.LastException.GetExceptionText(kvp.Value.PausedAt)))];

        return new DirectorStateExternal
        (
            Identifier,
            actorStates.Length,
            TotalQueuedMessageCount,
            actorStates,
            IsBusy(),
            LastActive.ToRelativeTimeWithLocal()
        );
    }

    /// <summary>
    /// Registers an actor under a unique identifier, spins up its mailbox and dispatch loop.
    /// </summary>
    /// <param name="actorId">Unique key for this actor instance.</param>
    /// <param name="actorFactory">Factory creating the actor implementation.</param>
    public void RegisterActor(string actorId, Func<IActor> actorFactory)
    {
        ThrowIfDisposed();

        ArgumentException.ThrowIfNullOrWhiteSpace(nameof(actorId));

        if (Registry.ContainsKey(actorId))
        {
            throw new ActorIdAlreadyRegisteredException(actorId);
        }

        IMailbox mailbox = Options.MailboxType switch
        {
            MailboxType.ConcurrentQueue => new ConcurrentQueueMailbox(Options, Logger),

            _ => throw new MailboxTypeNotHandledException(Options.MailboxType, nameof(Director))
        };

        IActor actor = actorFactory();
        ActorContext context = new(actorId, this);
        CancellationTokenSource cts = new();

        ActorState actorState = new(EventBus, mailbox, actor, context, cts, GetRetryPolicy(actorId), DispatchLoopTransactionalAsync);

        Registry[actorId] = actorState;
    }

    /// <summary>
    /// Resumes all actors that were previously paused. All queued messages will be processed.
    /// </summary>
    /// <returns></returns>
    public void ResumeActors()
    {
        foreach (string actorId in Registry.Keys)
        {
            ResumeActor(actorId);
        }
    }

    private string ResumeActor(string actorId)
    {
        ThrowIfDisposed();

        if (!Registry.TryGetValue(actorId, out ActorState? actorState))
        {
            return string.Format(ActorNotFoundFormat, actorId);
        }

        if (!actorState.IsPaused)
        {
            return ActorAlreadyProcessing;
        }

        Logger.LogInformation(ResumingActor, actorId);

        actorState.Resume(DispatchLoopTransactionalAsync);

        return ActorResumed;
    }

    /// <summary>
    /// Delivers a message to the specified actor’s mailbox.
    /// </summary>
    /// <param name="actorId">Target actor’s identifier.</param>
    /// <param name="message">The message to deliver.</param>
    public ValueTask Send(string actorId, IMessage message)
    {
        ThrowIfDisposed();

        if (!Registry.TryGetValue(actorId, out ActorState? actorState))
        {
            throw new ActorIdNotFoundException(actorId);
        }

        if (actorState.IsPaused)
        {
            throw new ActorPausedException(actorId);
        }

        //It blocks the current thread until the event is signaled via Set().
        //If the event is already set, Wait() returns immediately.
        actorState.PauseGate.Wait(actorState.CancellationSource.Token);

        EventBus.Publish(new DirectorReceivedMessageEvent(actorId));

        // backpressure will apply if mailbox is full
        return actorState.Mailbox.EnqueueAsync(message, actorState.CancellationSource.Token);
    }
}

// ===== File: ActorFramework\Runtime\Orchestration\Workspace.cs =====
using ActorFramework.Abstractions;
using ActorFramework.Base;
using ActorFramework.Configs;
using ActorFramework.Constants;
using ActorFramework.Events;
using ActorFramework.Events.Poco;
using ActorFramework.Extensions;
using ActorFramework.Models;

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace ActorFramework.Runtime.Orchestration;

public partial class Workspace : IdentifiableBase, IWorkspace
{
    private readonly ActorRegistrationBuilder _actorRegistrationBuilder;
    private readonly IOptions<ActorFrameworkOptions> _options;
    private readonly ILogger _logger;
    private readonly ILoggerFactory _loggerFactory;
    private readonly IServiceProvider _serviceProvider;
    private readonly IEventBus _eventBus;
    private readonly List<IDirector> _directors = [];
    private readonly Lock _lock = new();

    public Workspace(ActorRegistrationBuilder actorRegistrationBuilder, IOptions<ActorFrameworkOptions> options, ILogger<Workspace> logger, ILoggerFactory loggerFactory, IServiceProvider serviceProvider, IEventBus eventBus)
    {
        _options = options;
        _logger = logger;
        _loggerFactory = loggerFactory;
        _serviceProvider = serviceProvider;
        _eventBus = eventBus;
        _actorRegistrationBuilder = actorRegistrationBuilder;

        CreateDirector(); // bootstrap 1 director
    }

    public IReadOnlyList<IDirector> Directors
    {
        get { lock (_lock) return [.. _directors]; }
    }

    public IDirector? CreateDirector()
    {
        ThrowIfDisposed();

        lock (_lock)
        {
            if (_directors.Count >= _options.Value.MaxDegreeOfParallelism)
            {
                _eventBus.Publish(new WorkspaceCapacityReachedEvent(Identifier));
                return null;
            }

            Director director = new(_options, _loggerFactory.CreateLogger<Director>(), _eventBus);

            _eventBus.Publish(new DirectorRegisteredEvent(director.Identifier, Identifier));

            foreach (Type actorType in _actorRegistrationBuilder.ActorTypes)
            {
                director.RegisterActor(actorType.Name, () => (IActor)ActivatorUtilities.CreateInstance(_serviceProvider, actorType));
            }

            _directors.Add(director);
            return director;
        }
    }

    public void RemoveDirector(IDirector director)
    {
        ThrowIfDisposed();

        lock (_lock)
        {
            _logger.LogInformation(ActorFrameworkConstants.RemovingDirector, director.Identifier);

            _directors.Remove(director);
            director.Dispose();

            _eventBus.Publish(new DirectorDisposedEvent(director.Identifier, Identifier));
        }
    }

    public void Resume()
    {
        ThrowIfDisposed();

        foreach (IDirector director in _directors)
        {
            director.ResumeActors();
        }
    }

    public WorkspaceStateExternal GetState()
    {
        DirectorStateExternal[] directorStates = [.. _directors.Select(x => x.GetState())];
        return new WorkspaceStateExternal(Identifier, directorStates.Length, directorStates);
    }
}

public partial class Workspace : IEventListener<ThreadInformationEvent>
{
    public void OnEvent(ThreadInformationEvent evt)
    {
        _logger.LogInformation(ActorFrameworkConstants.ThreadRunningDirector, evt.ThreadId, evt.DirectorId, evt.ActorId);
    }
}

public partial class Workspace : IDisposable, IAsyncDisposable
{
    private bool _disposed;

    protected void ThrowIfDisposed() => ObjectDisposedException.ThrowIf(_disposed, GetType());
    protected virtual void Dispose(bool disposing)
    {
        if (_disposed)
        {
            return;
        }
        if (disposing)
        {
            // Synchronously wait for your async cleanup 
            DisposeInternal().GetAwaiter().GetResult();
        }
        _disposed = true;
    }
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
    // Async Dispose implementation
    public async ValueTask DisposeAsync()
    {
        if (_disposed)
        {
            return;
        }
        await DisposeInternal().ConfigureAwait(false);
        _disposed = true;
        GC.SuppressFinalize(this);
    }

    private Task DisposeInternal()
    {
        try
        {
            _logger.LogInformation(ActorFrameworkConstants.ShuttingDownWorkspaceDisposingDirectors);

            foreach (IDirector director in _directors)
            {
                RemoveDirector(director);
            }
        }
        catch
        {
            //ignore exceptions during shutdown
        }

        return Task.CompletedTask;
    }
}

// ===== File: ActorFramework\Runtime\Orchestration\WorkspaceLoadBalancer.cs =====
using ActorFramework.Abstractions;
using ActorFramework.Configs;
using ActorFramework.Extensions;

using Microsoft.Extensions.Options;

namespace ActorFramework.Runtime.Orchestration;

public class WorkspaceLoadBalancer(ActorRegistrationBuilder actorRegistrationBuilder, IWorkspace workspace, IOptions<ActorFrameworkOptions> options)
{
    public async Task RouteAsync(IMessage message)
    {
        Type messageType = message.GetType();

        if (!actorRegistrationBuilder.MessageToActorMap.TryGetValue(messageType, out Type? actorType))
            throw new InvalidOperationException($"No actor registered for message type {messageType.Name}");

        string actorId = actorType.Name; // or any unique string you use as ID

        IDirector director =
            workspace.GetFirstAvailableDirector()
            ?? workspace.CreateDirector()
            ?? workspace.GetLeastLoadedIdleDirector();

        await director.Send(actorId, message);
    }

    public void PruneIdleDirectors()
    {
        DateTimeOffset idleCutoff = DateTimeOffset.UtcNow - TimeSpan.FromSeconds(options.Value.DirectorIdleThresholdForPruning);

        foreach (IDirector? d in workspace.Directors
            .Where(d => d.LastActive < idleCutoff)
            .Skip(1) // keep at least one
            .ToList())
        {
            workspace.RemoveDirector(d);
        }
    }
}

public static class WorkspaceExtensions
{
    public static IDirector? GetFirstAvailableDirector(this IWorkspace workspace)
    {
        return workspace.Directors
            .OrderBy(d => d.IsBusy()) // Prioritize not busy
            .FirstOrDefault(d => !d.IsBusy());
    }

    public static IDirector GetLeastLoadedIdleDirector(this IWorkspace workspace)
    {
        return workspace.Directors
            .OrderBy(d => d.TotalQueuedMessageCount) // least messages in mailbox
            .ThenBy(d => d.LastActive) // then by last active time
            .First();
    }
}

// ===== File: ActorWorkspace\Runtime\Infrastructure\Workspace.cs =====
using ActorFramework.Abstractions;
using ActorFramework.Configs;
using ActorFramework.Models;
using ActorFramework.Runtime.Orchestration;

using ActorWorkspace.Abstractions;
using ActorWorkspace.Extensions;
using ActorWorkspace.Models;

using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace ActorWorkspace.Runtime.Infrastructure;

public class Workspace : IWorkspace
{
    private readonly ActorRegistrationBuilder _actorRegistrationBuilder;
    private readonly IOptions<ActorFrameworkOptions> _options;
    private readonly ILogger _logger;
    private readonly ILoggerFactory _loggerFactory;
    private readonly List<IDirector<IMessage>> _directors = [];
    private readonly Lock _lock = new();

    public Workspace(ActorRegistrationBuilder actorRegistrationBuilder, IOptions<ActorFrameworkOptions> options, ILogger<Workspace> logger, ILoggerFactory loggerFactory)
    {
        _options = options;
        _logger = logger;
        _loggerFactory = loggerFactory;
        _actorRegistrationBuilder = actorRegistrationBuilder;

        _directors.Add(CreateDirector()); // bootstrap 1 director
    }

    public IReadOnlyList<IDirector<IMessage>> Directors
    {
        get { lock (_lock) return [.. _directors]; }
    }

    public IDirector<IMessage> CreateDirector()
    {
        lock (_lock)
        {
            if (_directors.Count >= _options.Value.MaxDegreeOfParallelism)
                throw new InvalidOperationException("Max directors reached");

            _logger.LogInformation("Creating director");
            Director<IMessage> director = new(_options, _loggerFactory.CreateLogger<Director<IMessage>>());

            foreach (Type actorType in _actorRegistrationBuilder.ActorTypes)
            {
                director.RegisterActor(actorType.Name, () => (IActor<IMessage>)Activator.CreateInstance(actorType)!);
            }

            _directors.Add(director);
            return director;
        }
    }

    public void RemoveDirector(IDirector<IMessage> director)
    {
        lock (_lock)
        {
            _logger.LogInformation("Removing director");
            _directors.Remove(director);
            director.Dispose();
        }
    }

    public void Resume()
    {
        foreach (IDirector<IMessage> director in _directors)
        {
            director.ResumeActors();
        }
    }

    public WorkspaceStateExternal<IMessage> GetState()
    {
        DirectorStateExternal<IMessage>[] directorStates = [.. _directors.Select(x => x.GetState())];
        return new WorkspaceStateExternal<IMessage>(directorStates.Length, directorStates);
    }
}

// ===== File: ActorWorkspace\Runtime\Orchestration\WorkspaceLoadBalancer.cs =====
using ActorFramework.Abstractions;
using ActorFramework.Configs;

using ActorWorkspace.Abstractions;
using ActorWorkspace.Extensions;

using Microsoft.Extensions.Options;

namespace ActorWorkspace.Runtime.Orchestration;

public class WorkspaceLoadBalancer(ActorRegistrationBuilder actorRegistrationBuilder, IWorkspace workspace, IOptions<ActorFrameworkOptions> options)
{
    public async Task RouteAsync(IMessage message)
    {
        Type messageType = message.GetType();

        if (!actorRegistrationBuilder.MessageToActorMap.TryGetValue(messageType, out Type? actorType))
            throw new InvalidOperationException($"No actor registered for message type {messageType.Name}");

        string actorId = actorType.Name; // or any unique string you use as ID

        IDirector<IMessage>? director = workspace.Directors
            .OrderBy(d => d.IsBusy()) // or by queue length
            .FirstOrDefault(d => !d.IsBusy());

        if (director == null)
        {
            if (workspace.Directors.Count < options.Value.MaxDegreeOfParallelism)
                director = workspace.CreateDirector();
            else
                director = workspace.Directors.OrderBy(d => d.LastActive).First();
        }

        await director.Send(actorId, message);
    }

    public void PruneIdleDirectors()
    {
        DateTimeOffset idleCutoff = DateTimeOffset.UtcNow - TimeSpan.FromSeconds(options.Value.DirectorIdleThresholdForPruning);

        foreach (IDirector<IMessage>? d in workspace.Directors
            .Where(d => d.LastActive < idleCutoff)
            .Skip(1) // keep at least one
            .ToList())
        {
            workspace.RemoveDirector(d);
        }
    }
}

// ===== File: ActorFramework\obj\Debug\net9.0\.NETCoreApp,Version=v9.0.AssemblyAttributes.cs =====
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]


// ===== File: ActorFramework\obj\Debug\net9.0\ActorFramework.AssemblyInfo.cs =====
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("ActorFramework")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+5c4caabca0a06f881f6baab64e11e3b88daffdd1")]
[assembly: System.Reflection.AssemblyProductAttribute("ActorFramework")]
[assembly: System.Reflection.AssemblyTitleAttribute("ActorFramework")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



// ===== File: ActorFramework\obj\Debug\net9.0\ActorFramework.GlobalUsings.g.cs =====
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;


// ===== File: ActorFramework\Runtime\Infrastructure\Internal\MailboxTransaction.cs =====
using System.Collections.Concurrent;

using ActorFramework.Abstractions;

namespace ActorFramework.Runtime.Infrastructure.Internal;

public sealed class MailboxTransaction
{
    private readonly ConcurrentQueue<IMessage>? _queue;
    private readonly IMessage _message;
    private readonly Action<IMessage> _onCommit;
    private readonly Action<IMessage> _onRollback;

    internal MailboxTransaction(ConcurrentQueue<IMessage>? queue, IMessage message, Action<IMessage> onCommit, Action<IMessage> onRollback)
    {
        _queue = queue;
        _message = message;
        _onCommit = onCommit;
        _onRollback = onRollback;
    }

    public IMessage Message => _message;

    public Task<bool> CommitAsync()
    {
        //non-transactional mailboxes (like UnboundedMailbox) will not have a queue, so we can commit immediately
        if (_queue == null || (_queue.TryDequeue(out IMessage? dequeued) && ReferenceEquals(dequeued, _message)))
        {
            _onCommit(_message);
            return Task.FromResult(true);
        }

        return Task.FromResult(false);
    }

    public Task RollbackAsync()
    {
        _onRollback(_message);
        return Task.CompletedTask;
    }
}

// ===== File: ActorFramework\Runtime\Orchestration\Internal\BaseDirector.cs =====
using ActorFramework.Base;
using ActorFramework.Configs;
using ActorFramework.Events;

using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace ActorFramework.Runtime.Orchestration.Internal;

public abstract partial class BaseDirector(IOptions<ActorFrameworkOptions> options, ILogger<Director> logger, IEventBus eventBus) : IdentifiableBase
{
    protected readonly ActorFrameworkOptions Options = options.Value ?? throw new ArgumentNullException(nameof(options));
    protected readonly ILogger<Director> Logger = logger ?? throw new ArgumentNullException(nameof(logger));
    protected readonly IEventBus EventBus = eventBus ?? throw new ArgumentNullException(nameof(eventBus));
}

// ===== File: ActorFramework\Runtime\Orchestration\Internal\BaseDirector.DispatchLoopTransactional.cs =====
using ActorFramework.Constants;
using ActorFramework.Events.Poco;
using ActorFramework.Runtime.Infrastructure.Internal;

using Microsoft.Extensions.Logging;

namespace ActorFramework.Runtime.Orchestration.Internal;

/// <summary>
/// Contains the dispatch loop logic for actors and retry policies.
/// </summary>
/// <typeparam name="TMessage"></typeparam>
public abstract partial class BaseDirector
{
    protected async Task DispatchLoopTransactionalAsync(ActorState actorState, CancellationToken cancellationToken)
    {
        try
        {
            await foreach (MailboxTransaction mailboxTransaction in actorState.Mailbox.DequeueAsync(cancellationToken))
            {
                // Block here if actor is paused
                actorState.PauseGate.Wait(cancellationToken);

                eventBus.Publish(new ThreadInformationEvent(Identifier, actorState.Identifier, Environment.CurrentManagedThreadId.ToString()));

                try
                {
                    // Execute actor logic with retry
                    await actorState.RetryPolicy.ExecuteAsync(
                        async token =>
                        {
                            actorState.OnMessageReceived();

                            // ConfigureAwait so that you don’t capture a SynchronizationContext or “sticky” context from the caller
                            await actorState.Actor.OnReceive(mailboxTransaction.Message, actorState.Context.ToExternal(actorState.PendingMessageCount, actorState.LastMessageReceivedTimestamp), token).ConfigureAwait(false);
                        },
                        cancellationToken
                    );

                    //commit the transaction after successful processing
                    if (!await mailboxTransaction.CommitAsync())
                    {
                        Logger.LogWarning(ActorFrameworkConstants.CommitFailedAsMessageWasNotAtHeadOfQueue);
                    }

                    actorState.OnMessageCommitted();
                }
                catch (Exception ex)
                {
                    await actorState.Actor.OnError(actorState.Context.ActorId, mailboxTransaction.Message, ex).ConfigureAwait(false);

                    if (Options.ShouldStopOnUnhandledException)
                    {
                        Logger.LogError(ex, ActorFrameworkConstants.ActorFaultedAfterMaxRetriesPausing, actorState.Context.ActorId);

                        await mailboxTransaction.RollbackAsync();

                        actorState.OnMessageFailed(ex);

                        //STOP:  no processing further messages
                        break;
                    }
                    else
                    {
                        logger.LogWarning(ex, ActorFrameworkConstants.ActorSkippingFailedMessage, actorState.Context.ActorId);

                        //commit the transaction even after UN-successful processing
                        if (!await mailboxTransaction.CommitAsync())
                        {
                            Logger.LogWarning(ActorFrameworkConstants.CommitFailedAsMessageWasNotAtHeadOfQueue);
                        }

                        actorState.OnMessageCommitted();
                    }
                }
            }
        }
        catch (OperationCanceledException)
        {
            // normal shutdown path
        }
    }
}

// ===== File: ActorFramework\Runtime\Orchestration\Internal\BaseDirector.Disposable.cs =====
using ActorFramework.Constants;

using Microsoft.Extensions.Logging;

namespace ActorFramework.Runtime.Orchestration.Internal;

public abstract partial class BaseDirector : IDisposable, IAsyncDisposable
{
    protected void ThrowIfDisposed() => ObjectDisposedException.ThrowIf(_disposed, typeof(Director));

    protected virtual void Cleanup()
    {
        // This method can be overridden by derived classes to perform additional cleanup.
        // The base implementation does nothing.
    }

    private async Task DisposeInternal()
    {
        if (_disposed)
        {
            return;
        }

        try
        {
            Logger.LogInformation(ActorFrameworkConstants.ShuttingDownDirectorCancellingActors);

            Cleanup();

            Logger.LogInformation(ActorFrameworkConstants.DispatchLoopsCompletedDisposingMailboxes);

            foreach (ActorState actorState in Registry.Values)
            {
                await actorState.DisposeAsync();
            }

            Registry.Clear();
        }
        catch
        {
            //ignore exceptions during shutdown
        }
    }

    private bool _disposed;

    protected virtual void Dispose(bool disposing)
    {
        if (_disposed)
        {
            return;
        }

        if (disposing)
        {
            // Synchronously wait for your async cleanup 
            DisposeInternal().GetAwaiter().GetResult();
        }

        _disposed = true;
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    // Async Dispose implementation
    public async ValueTask DisposeAsync()
    {
        if (_disposed)
        {
            return;
        }

        await DisposeInternal().ConfigureAwait(false);
        _disposed = true;
        GC.SuppressFinalize(this);
    }
}

// ===== File: ActorFramework\Runtime\Orchestration\Internal\BaseDirector.Registry.cs =====
using System.Collections.Concurrent;

using ActorFramework.Abstractions;
using ActorFramework.Base;
using ActorFramework.Events;
using ActorFramework.Events.Poco;
using ActorFramework.Models;

using Polly.Retry;

namespace ActorFramework.Runtime.Orchestration.Internal;

/// <summary>
/// Contains the registry of actors and their states.
/// </summary>
/// <typeparam name="TMessage"></typeparam>
/// <param name="options"></param>
/// <param name="logger"></param>
public abstract partial class BaseDirector
{
    // In-memory actorState of all actors
    protected readonly ConcurrentDictionary<string, ActorState> Registry = new();

    /// <summary>
    /// Internal holder of per-actor resources.
    /// </summary>
    protected sealed class ActorState : IdentifiableBase, IDisposable, IAsyncDisposable
    {
        public IEventBus EventBus { get; init; }
        public IMailbox Mailbox { get; init; }
        public IActor Actor { get; init; }
        public ActorContext Context { get; init; }
        public CancellationTokenSource CancellationSource { get; init; }
        public AsyncRetryPolicy RetryPolicy { get; init; }
        public Task DispatchTask { get; set; }

        //used for pausing/resuming message processing - pause is a word used to indicate that the actor is not processing messages at the moment.
        //this is not a blocking pause, but rather a signal to the dispatch loop to wait until it is resumed.
        public ManualResetEventSlim PauseGate { get; } = new(true);
        public bool IsPaused { get; private set; }
        public Exception? LastException { get; private set; }
        public DateTimeOffset? PausedAt { get; private set; }
        public DateTimeOffset LastMessageReceivedTimestamp { get; private set; } = DateTimeOffset.MinValue;
        public int PendingMessageCount => Mailbox.Count;

        public ActorState(IEventBus eventBus, IMailbox mailbox, IActor actor, ActorContext context, CancellationTokenSource cancellationSource, AsyncRetryPolicy retryPolicy, Func<ActorState, CancellationToken, Task> dispatchLoop)
        {
            this.EventBus = eventBus;
            this.Mailbox = mailbox;
            this.Actor = actor;
            this.Context = context;
            this.CancellationSource = cancellationSource;
            this.RetryPolicy = retryPolicy;
            this.DispatchTask = Task.Run(() => dispatchLoop(this, CancellationSource.Token));

            eventBus.Publish(new ActorRegisteredEvent(context.ActorId, context.Director.Identifier));
        }

        public void Resume(Func<ActorState, CancellationToken, Task> dispatchLoop)
        {
            EventBus.Publish(new ActorResumedEvent(Context.ActorId));

            IsPaused = false;
            PauseGate.Set();
            LastException = null;
            PausedAt = null;

            if (DispatchTask.IsCompleted)
            {
                DispatchTask = Task.Run(() => dispatchLoop(this, CancellationSource.Token));
            }
        }

        public void OnMessageReceived()
        {
            EventBus.Publish(new ActorReceivedMessageEvent(Context.ActorId));

            LastMessageReceivedTimestamp = DateTimeOffset.UtcNow;
        }

        public void OnMessageCommitted()
        {
            // Raise an idle event if the mailbox is empty after processing
            if (Mailbox.Count == 0)
            {
                EventBus.Publish(new ActorIdleEvent(Context.ActorId));
            }
        }

        public void OnMessageFailed(Exception ex)
        {
            EventBus.Publish(new ActorPausedEvent(Context.ActorId, ex));

            IsPaused = true;
            PauseGate.Reset(); //closes the gate until manually resumed by Set()

            if (ex != null)
            {
                LastException = ex;
                PausedAt = DateTimeOffset.UtcNow;
            }
        }

        #region Disposal

        private async Task DisposeInternal()
        {
            try
            {
                EventBus.Publish(new ActorDisposedEvent(Context.ActorId));

                try
                {
                    await CancellationSource.CancelAsync();
                }
                catch
                {
                    //ignore cancellation exceptions
                }

                await DispatchTask;

                Mailbox.Dispose();
                CancellationSource.Dispose();
                PauseGate.Dispose();
            }
            catch
            {
                //ignore exceptions during shutdown
            }
        }

        private bool _disposed;

        ~ActorState() => Dispose(false);

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (_disposed)
            {
                return;
            }

            _disposed = true;

            if (disposing)
            {
                DisposeInternal().GetAwaiter().GetResult();
            }
        }

        // Async Dispose implementation
        public async ValueTask DisposeAsync()
        {
            if (_disposed)
            {
                return;
            }

            await DisposeInternal().ConfigureAwait(false);
            _disposed = true;
            GC.SuppressFinalize(this);
        }

        #endregion
    }
}

// ===== File: ActorFramework\Runtime\Orchestration\Internal\BaseDirector.RetryPolicy.cs =====
using ActorFramework.Constants;

using Microsoft.Extensions.Logging;

using Polly;
using Polly.Retry;

namespace ActorFramework.Runtime.Orchestration.Internal;

/// <summary>
/// Contains the dispatch loop logic for actors and retry policies.
/// </summary>
/// <typeparam name="TMessage"></typeparam>
public abstract partial class BaseDirector
{
    protected AsyncRetryPolicy GetRetryPolicy(string actorId) => Policy
        .Handle<Exception>(ex => ex is not OperationCanceledException && ex is not TaskCanceledException)
        .RetryAsync(
            Options.RetryCountIfExceptionOccurs,
            onRetry: (ex, attemptNumber, _) =>
            {
                Logger.LogWarning(ex, ActorFrameworkConstants.ActorRetryingOnMessage, actorId, attemptNumber, Options.RetryCountIfExceptionOccurs);
            });
}

// ===== File: ActorFramework.AspNetCore\obj\Debug\net9.0\.NETCoreApp,Version=v9.0.AssemblyAttributes.cs =====
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]


// ===== File: ActorFramework.AspNetCore\obj\Debug\net9.0\ActorFramework.AspNetCore.AssemblyInfo.cs =====
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("ActorFramework.AspNetCore")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+5c4caabca0a06f881f6baab64e11e3b88daffdd1")]
[assembly: System.Reflection.AssemblyProductAttribute("ActorFramework.AspNetCore")]
[assembly: System.Reflection.AssemblyTitleAttribute("ActorFramework.AspNetCore")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



// ===== File: ActorFramework.AspNetCore\obj\Debug\net9.0\ActorFramework.AspNetCore.GlobalUsings.g.cs =====
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;


// ===== File: ActorSystem\obj\Debug\net9.0\.NETCoreApp,Version=v9.0.AssemblyAttributes.cs =====
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]


// ===== File: ActorSystem\obj\Debug\net9.0\ActorSystem.AssemblyInfo.cs =====
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("ActorSystem")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+5c4caabca0a06f881f6baab64e11e3b88daffdd1")]
[assembly: System.Reflection.AssemblyProductAttribute("ActorSystem")]
[assembly: System.Reflection.AssemblyTitleAttribute("ActorSystem")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



// ===== File: ActorSystem\obj\Debug\net9.0\ActorSystem.GlobalUsings.g.cs =====
// <auto-generated/>
global using global::Microsoft.AspNetCore.Builder;
global using global::Microsoft.AspNetCore.Hosting;
global using global::Microsoft.AspNetCore.Http;
global using global::Microsoft.AspNetCore.Routing;
global using global::Microsoft.Extensions.Configuration;
global using global::Microsoft.Extensions.DependencyInjection;
global using global::Microsoft.Extensions.Hosting;
global using global::Microsoft.Extensions.Logging;
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Net.Http.Json;
global using global::System.Threading;
global using global::System.Threading.Tasks;


