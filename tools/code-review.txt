
## Concurrency and correctness issues

- **Actor identity and message ordering are not guaranteed.**
  - Today, every new Director registers the same actors by type name (e.g., “ContestActor”), and the load balancer picks any director. That spawns multiple instances of the “same” actor across directors and breaks single-threaded, in-order guarantees per actor instance.
  - Fix: derive an actorId from the message (domain key), pin that actorId to exactly one director, and register the actor lazily on that director.

- **Event signal semantics are inconsistent.**
  - You have both ActorReceivedMessageEvent and DirectorReceivedMessageEvent. Only the actor event drives LastActive, while Send publishes the director event that no one consumes. Choose one signal for “activity” and be consistent.

- **Mailbox overflow behavior under load.**
  - BlockProducer does a spin delay. With many producers, it can amplify contention and delay propagation. Consider supporting a TryEnqueueAsync with timeout and/or a backpressure callback. At minimum, log at debug level to avoid log storms under pressure.

- **Potentially misleading state reporting.**
  - MailboxStateExternal exposes the raw IMessage array. That can be heavy and may expose sensitive payloads. Prefer counts and a few sample metadata fields.

---

## Design refactors to simplify and scale

### 1) Stop pre-registering actors on every director
- Change Workspace.CreateDirector to not register all actor types. Let directors start empty.
- Route-time registration ensures a single actor instance (per actorId) exists on exactly one director.

```csharp
// Workspace.CreateDirector (remove the loop)
Director director = new(_options, _loggerFactory.CreateLogger<Director>(), _eventBus);
_eventBus.Publish(new DirectorRegisteredEvent(director.Identifier, Identifier));
_directors.Add(director);
return director;
```

### 2) Introduce a predictable actorId and sticky routing
- Add an IActorIdResolver to derive a stable actorId from IMessage (e.g., ContestMessage.Key, PropositionMessage.Key).
- Maintain a ConcurrentDictionary<string, IDirector> to pin that actorId to a director. If the director disappears, remap on next route.

```csharp
public interface IActorIdResolver
{
    string Resolve(IMessage message);
    Type ResolveActorType(IMessage message);
}

// Example resolver for your messages:
public sealed class DefaultActorIdResolver : IActorIdResolver
{
    public string Resolve(IMessage message) => message switch
    {
        ActorSystem.Messages.ContestMessage m      => $"Contest:{m.Key}",
        ActorSystem.Messages.PropositionMessage m  => $"Proposition:{m.Key}",
        _ => message.GetType().Name // fallback
    };

    public Type ResolveActorType(IMessage message) =>
        message switch
        {
            ActorSystem.Messages.ContestMessage      => typeof(ActorSystem.Actors.ContestActor),
            ActorSystem.Messages.PropositionMessage  => typeof(ActorSystem.Actors.PropositionActor),
            _ => throw new InvalidOperationException($"No actor registered for {message.GetType().Name}")
        };
}
```

```csharp
// WorkspaceLoadBalancer: pinning map + lazy registration
public class WorkspaceLoadBalancer
{
    private readonly ActorRegistrationBuilder _builder;
    private readonly IWorkspace _workspace;
    private readonly IOptions<ActorFrameworkOptions> _options;
    private readonly IServiceProvider _sp;
    private readonly IActorIdResolver _resolver;
    private readonly ConcurrentDictionary<string, IDirector> _routing = new();

    public WorkspaceLoadBalancer(
        ActorRegistrationBuilder builder,
        IWorkspace workspace,
        IOptions<ActorFrameworkOptions> options,
        IServiceProvider sp,
        IActorIdResolver resolver)
    {
        _builder = builder;
        _workspace = workspace;
        _options = options;
        _sp = sp;
        _resolver = resolver;
    }

    public async Task RouteAsync(IMessage message)
    {
        string actorId = _resolver.Resolve(message);
        Type actorType = _resolver.ResolveActorType(message);

        IDirector director = _routing.GetOrAdd(actorId, _ =>
            _workspace.GetFirstAvailableDirector()
            ?? _workspace.CreateDirector()
            ?? _workspace.GetLeastLoadedIdleDirector());

        try
        {
            // Send fast-path
            await director.Send(actorId, message);
        }
        catch (ActorIdNotFoundException)
        {
            // Lazy register and retry
            director.RegisterActor(actorId, () => (IActor)ActivatorUtilities.CreateInstance(_sp, actorType));
            await director.Send(actorId, message);
        }
        catch (ObjectDisposedException)
        {
            // Director was pruned; remap and retry
            _routing.TryRemove(actorId, out _);
            await RouteAsync(message);
        }
    }

    public void PruneIdleDirectors()
    {
        // unchanged logic…
    }
}
```

- This preserves strict per-actor ordering while scaling horizontally across many actorIds.

### 3) Simplify selection heuristics
- Replace “IsBusy” heuristic with queue depth. It’s clearer and fairer.
```csharp
public static IDirector? GetFirstAvailableDirector(this IWorkspace workspace)
    => workspace.Directors.OrderBy(d => d.TotalQueuedMessageCount).FirstOrDefault();

public static IDirector GetLeastLoadedIdleDirector(this IWorkspace workspace)
    => workspace.Directors.OrderBy(d => d.TotalQueuedMessageCount).ThenBy(d => d.LastActive).First();
```

### 4) Remove PauseGate from Send
- Let only the dispatch loop honor PauseGate. Producers should enqueue or fail fast.
```csharp
// Director.Send
// Remove PauseGate.Wait(...)
```

### 5) Tighten public surface for clarity and composition
- Consider adding a non-throwing send (e.g., TrySend with timeout) to pair with overflow policies.
- Add HasActor or TryRegister to IDirector if you prefer explicit probing vs exception control-flow.

---

## Operational hardening and observability

- **Metrics-first:** Expose counters/gauges for:
  - per-director total queued messages, per-actor mailbox depth
  - enqueue failures by overflow policy
  - actor retries, pauses, resumes
  - pruning events and reasons
- **Structured events:** All event payloads already have identifiers and timestamps — great. Ensure they’re logged at appropriate levels and sampled under load.
- **Safer state endpoints:** Redact or omit full Messages; return counts and a few metadata fields instead.
- **Pruning safety:** When pruning, remove from the routing map any actorIds pinned to a pruned director to avoid blackholes (see ObjectDisposedException path in the load balancer above).

---

## Quick patches (ready to apply)

- Stop pre-registering actors in Workspace.CreateDirector (snippet above) and implement sticky routing with lazy registration (snippets above).

- Prefer queue-depth–based director selection (snippet above).

---
